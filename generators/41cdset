#!/bin/sh
set -e

. /usr/share/debconf/confmodule
. /lib/chroot-setup.sh

log() {
	logger -t apt-setup "$@"
}

# This code is copied from chroot-setup.sh, and is needed until after a d-i
# release whose initrds contain a sufficiently new version of di-utils.
if ! type chroot_cleanup_localmounts >/dev/null 2>&1; then
	# Variant of chroot_cleanup that only cleans up chroot_setup's mounts.
	chroot_cleanup_localmounts () {
		rm -f /target/usr/sbin/policy-rc.d
		if [ -f /target/sbin/start-stop-daemon.REAL ]; then
			mv /target/sbin/start-stop-daemon.REAL /target/sbin/start-stop-daemon
		fi
		if [ -x /target/sbin/initctl.REAL ]; then
			mv /target/sbin/initctl.REAL /target/sbin/initctl
		fi
		# Undo the mounts done by the packages during installation.
		# Reverse sorting to umount the deepest mount points first.
		# Items with count of 1 are new.
		for dir in $( (cat /tmp/mount.pre /tmp/mount.pre /tmp/mount.post ) | \
			     sort -r | uniq -c | grep "^[[:space:]]*1[[:space:]]" | \
			     sed "s/^[[:space:]]*[0-9][[:space:]]//"); do
			if ! umount $dir; then
				logger -t $0 "warning: Unable to umount '$dir'"
			fi
		done
		rm -f /tmp/mount.pre /tmp/mount.post

		rm -f /var/run/chroot-setup.lock
	}
fi

file="$1"

if [ ! -e /cdrom/.disk/cd_type ] || [ ! -e /var/lib/install-cd.id ]; then
	exit 0
fi
# multi-arch CDs have cd_type 'non_complete'
# KDE/Xfce CDs and multi-arch DVDs have '/single' postfix in cd_type
# bluray CDs have cd_type 'bluray'
cd_type=$(cat /cdrom/.disk/cd_type)
log "The disk type is: $cd_type"
if [ "$cd_type" != full_cd ] && [ "$cd_type" != dvd ]; then
	exit 0
fi

log "Starting disk set detection"

get_label() {
	LC_ALL=C $logoutput --pass-stdout $chroot $ROOT \
		apt-cdrom ident | grep "^Stored label:" | head -n1 | \
		sed "s/^[^:]*: //"
}

logoutput=""
if [ "$CATCHLOG" ]; then
	logoutput="log-output -t apt-setup"
fi


# Why isn't this function, or something like it,
# in /usr/share/debconf/confmodule ?
db_getval()
{
	db_get "$1" && echo "$RET" || true
}

# See whether /cdrom is a loopmounted ISO
loopdev=$(db_getval cdrom-detect/cdrom_loopdev)

chroot=
if [ "$ROOT" ]; then
	chroot=chroot

	# We can only change CDs if current CD is unmounted
	$logoutput umount /cdrom || true

	chroot_setup
	# Horrible hack to let us call a subprocess that also sources the
	# confmodule, since chroot_setup tears down debconf state.
	export DEBIAN_HAS_FRONTEND=1
	export DEBCONF_REDIR=1
	# Needed until after a d-i release with new enough di-utils.
	mountpoints > /tmp/mount.post
	trap chroot_cleanup_localmounts EXIT HUP INT QUIT TERM
fi

tmp=$($chroot $ROOT tempfile)

cd_label=$(tail -n1 /var/lib/install-cd.id)

if [ "$loopdev" ]; then
	run_count=0
	max_run=0
	# Load the mount parameters for the CD
	CDFS=$(db_getval cdrom-detect/cdrom_fs)
	[ "$CDFS" ] || CDFS=iso9660
	OPTIONS=$(db_getval cdrom-detect/cdrom_options)
	[ "$OPTIONS" ] || OPTIONS=ro,exec
fi

log "First installation disk: $cd_label"

db_subst apt-setup/cdrom/set-first LABEL "$cd_label"
db_input high apt-setup/cdrom/set-first || true
if ! db_go; then
	if [ "$ROOT" ]; then
		load-install-cd "$ROOT"
	fi
	exit 10
fi
db_get apt-setup/cdrom/set-first

while [ "$RET" = true ]; do
	cd_label=""
	if [ "$loopdev" ]; then
		if [ $run_count -eq 0 ]; then
			log "Trying to find usable ISOs in the folder, where the boot ISO is..."
			loopdir=$(db_getval cdrom-detect/cdrom_device)
			ISOname=$(basename $loopdir)
			loopdir=$(dirname $loopdir)
			if [ "$cd_type" = "dvd" ]; then
				# DVD
				ISOstart=${ISOname%DVD-*}
				ISOs=$(ls ${loopdir}/ | grep ${ISOstart}DVD-[^1].*[.]iso$)
			elif [ "$cd_type" = "blueray" ]; then
				# BD
				ISOstart=${ISOname%BD-*}
				ISOs=$(ls ${loopdir}/ | grep ${ISOstart}BD-[^1].*[.]iso$)
			else
				# probably CD
				ISOstart=${ISOname%CD-*}
				ISOs=$(ls ${loopdir}/ | grep ${ISOstart}CD-[^1].*[.]iso$)
			fi
			for iso in $ISOs; do
				max_run=$(($max_run + 1))
			done
			log "Found $max_run ISO(s): $ISOs"
		fi

		try_iso=0
		while [ $try_iso -eq 0 ]; do
			if [ $run_count -lt $max_run ]; then
				i=0
				ISO=""
				# select current ISO file
				for isofile in $ISOs; do
					if [ $i -eq $run_count ]; then
						ISO=$isofile
						break
					fi
					i=$(($i + 1))
				done
				j=1
				# create mount point for the ISO
				mount_point=/media/cdrom$j
				while [ -d $ROOT$mount_point ]; do
					j=$(($j + 1))
					mount_point=/media/cdrom$j
				done
				mkdir $ROOT$mount_point

				log "Try to loop mount file=$loopdir/$ISO, fstype=$CDFS to $ROOT$mount_point"
				if mount -t $CDFS -o loop,$OPTIONS $loopdir/$ISO $ROOT$mount_point; then
					log "CD-ROM mount succeeded: file=$loopdir/$ISO fstype=$CDFS"
					if [ -e $ROOT$mount_point/.disk/info ]; then
						CDNAME=$(cat $ROOT$mount_point/.disk/info | tr '"' '_')
						log "Detected disk '$CDNAME'"
						# Load the codename (e.g. jessie) from the database
						db_get cdrom/codename
						codename=$RET
						RET=""
						log "Detected codename: $codename"
						try_iso=1
					else
						log "The disk in $loopdir/$ISO is not a Debian disk!"
						umount $ROOT$mount_point 2>/dev/null || true
						rmdir $ROOT$mount_point
					fi
				else
					log "Mount failed: file=$loopdir/$ISO fstype=$CDFS"
					umount $ROOT$mount_point 2>/dev/null || true
					rmdir $ROOT$mount_point
				fi
			else
				log "No more ISOs found"
				break
			fi
			run_count=$(($run_count + 1))
		done
	fi

	if [ "$loopdev" ] && [ $try_iso -eq 1 ]; then
		cd_label=$CDNAME
	else
		cd_label=$(get_label)
	fi

	# Hmm. The greps could fail if a label contains regexp control chars...
	if [ "$cd_label" ] && \
	   (grep "^deb cdrom:\[$cd_label\]" $file || \
	    grep "^deb cdrom:\[$cd_label\]" $ROOT/etc/apt/sources.list.new); then
		template=apt-setup/cdrom/set-double
		db_subst $template LABEL "$cd_label"
	else
		if [ "$loopdev" ] && [ $try_iso -eq 1 ]; then
			# Add an entry for the mount point of the ISO
			printf "\ndeb [ trusted=yes ] file:$mount_point $codename main" >> $file
			log "added log entry: 'deb [ trusted=yes ] file:$mount_point $codename main'"

			# Make apt aware of the file
			$logoutput $chroot $ROOT apt-cdrom -d $mount_point  add \
			   -o Dir::Etc::SourceList=$tmp \
			   </dev/null;

			rm -f $ROOT$tmp $ROOT$tmp~

			template=apt-setup/cdrom/set-next
			db_subst $template LABEL "$cd_label"
		else
			# apt-cdrom can be interactive, avoid that
			if $logoutput $chroot $ROOT apt-cdrom add \
			   -o Dir::Etc::SourceList=$tmp \
			   </dev/null; then
				cat $ROOT$tmp >> $file

				# Label is assigned by apt-cdrom add, so get again
				cd_label=$(get_label)
				template=apt-setup/cdrom/set-next
				db_subst $template LABEL "$cd_label"
			else
				template=apt-setup/cdrom/set-failed
			fi
			rm -f $ROOT$tmp $ROOT$tmp~
		fi
	fi

	db_input critical $template || true
	if ! db_go; then
		if [ "$ROOT" ]; then
			load-install-cd "$ROOT"
		fi
		exit 10
	fi
	db_get $template
done

# Make sure the installation CD is loaded again
if [ "$ROOT" ]; then
	load-install-cd "$ROOT"
fi
